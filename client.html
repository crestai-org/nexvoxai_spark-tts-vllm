<!DOCTYPE html>
<html>
<head>
    <title>Spark TTS WebSocket Test</title>

</head>
<body>
    <h1>Spark TTS WebSocket Test</h1>
    <script
    src="http://localhost:3000/embed-popup.js"
    data-lk-sandbox-id="http://localhost:3000"
    ></script>
    <div>
        <label>Server URL:</label>
        <input type="text" id="serverUrl" value="ws://35.203.124.213:8000/v1/audio/speech/stream/ws" style="width: 400px;">
        <button onclick="connect()">Connect</button>
        <button onclick="disconnect()">Disconnect</button>
    </div>
    
    <div>
        <label>Connection Status:</label>
        <span id="connectionStatus">Disconnected</span>
    </div>
    
    <div>
        <label>Text:</label>
        <textarea id="textInput" rows="4" cols="50" placeholder="Enter text to convert to speech...">Hello, this is a test of the Spark TTS streaming system. I hope it works well!</textarea>
    </div>
    
    <div>
        <label>Voice:</label>
        <select id="voiceSelect">
            <option value="acholi_female">Acholi Female</option>
            <option value="ateso_female">Ateso Female</option>
            <option value="runyankore_female" selected>Runyankore Female</option>
            <option value="lugbara_female">Lugbara Female</option>
            <option value="swahili_male">Swahili Male</option>
            <option value="luganda_female">Luganda Female</option>
        </select>
    </div>
    
    <div>
        <label>Temperature:</label>
        <input type="range" id="temperatureSlider" min="0.1" max="1.0" step="0.1" value="0.7">
        <span id="temperatureValue">0.7</span>
    </div>
    
    <div>
        <button onclick="sendRequest()">Generate Speech</button>
        <button onclick="clearAudio()">Clear Audio</button>
        <button onclick="clearLogs()">Clear Logs</button>
    </div>
    
    <div>
        <label>Audio Status:</label>
        <span id="audioStatus">Ready</span>
    </div>
    
    <div>
        <h3>Connection Logs:</h3>
        <div id="logs" style="height: 200px; overflow-y: scroll; border: 1px solid #ccc; padding: 10px; font-family: monospace; font-size: 12px; white-space: pre-wrap;"></div>
    </div>

    <script>
        let websocket = null;
        let audioContext = null;
        let isPlaying = false;
        let isReceivingAudio = false;
        let currentSegmentId = null;
        let audioBufferQueue = [];

        // Temperature slider update
        document.getElementById('temperatureSlider').addEventListener('input', function(e) {
            document.getElementById('temperatureValue').textContent = e.target.value;
        });

        function addLog(message, type = 'info') {
            const logs = document.getElementById('logs');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.textContent = `[${timestamp}] ${message}`;
            
            // Simple color coding
            if (type === 'error') {
                logEntry.style.color = 'red';
            } else if (type === 'success') {
                logEntry.style.color = 'green';
            } else if (type === 'warning') {
                logEntry.style.color = 'orange';
            } else if (type === 'debug') {
                logEntry.style.color = 'gray';
            }
            
            logs.appendChild(logEntry);
            logs.scrollTop = logs.scrollHeight;
        }

        function updateConnectionStatus(status) {
            document.getElementById('connectionStatus').textContent = status;
        }

        function initializeAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                addLog(`Audio context initialized with sample rate: ${audioContext.sampleRate}`, 'info');
            }
        }

        function connect() {
            const url = document.getElementById('serverUrl').value;
            
            if (websocket) {
                websocket.close();
            }

            updateConnectionStatus('connecting');
            addLog(`Connecting to ${url}...`, 'info');

            try {
                websocket = new WebSocket(url);
                
                // Set connection timeout
                const connectionTimeout = setTimeout(() => {
                    if (websocket.readyState === WebSocket.CONNECTING) {
                        websocket.close();
                        updateConnectionStatus('disconnected');
                        addLog('Connection timeout - please check server and try again', 'error');
                    }
                }, 30000); // 30 second timeout

                websocket.onopen = function(event) {
                    clearTimeout(connectionTimeout);
                    updateConnectionStatus('connected');
                    addLog('WebSocket connection established', 'success');
                };

                websocket.onmessage = function(event) {
                    addLog(`Received message type: ${typeof event.data}, size: ${event.data.size || event.data.length || 'unknown'}`, 'debug');
                    
                    if (typeof event.data === 'string') {
                        // JSON message
                        try {
                            const message = JSON.parse(event.data);
                            addLog(`Received JSON: ${JSON.stringify(message)}`, 'debug');
                            handleJSONMessage(message);
                        } catch (e) {
                            addLog(`Failed to parse JSON: ${event.data}`, 'error');
                        }
                    } else if (event.data instanceof Blob) {
                        // Binary data as Blob (common in some WebSocket implementations)
                        addLog(`Received Blob data: ${event.data.size} bytes`, 'debug');
                        event.data.arrayBuffer().then(buffer => {
                            handleAudioData(buffer);
                        }).catch(e => {
                            addLog(`Error reading Blob: ${e.message}`, 'error');
                        });
                    } else {
                        // Binary data as ArrayBuffer
                        addLog(`Received ArrayBuffer data: ${event.data.byteLength} bytes`, 'debug');
                        handleAudioData(event.data);
                    }
                };

                websocket.onerror = function(event) {
                    addLog('WebSocket error occurred', 'error');
                    updateConnectionStatus('disconnected');
                };

                websocket.onclose = function(event) {
                    updateConnectionStatus('disconnected');
                    addLog(`WebSocket connection closed: ${event.code} ${event.reason}`, 'info');
                };

            } catch (error) {
                addLog(`Error creating WebSocket: ${error.message}`, 'error');
                updateConnectionStatus('error');
            }
        }

        function disconnect() {
            if (websocket) {
                websocket.close();
                websocket = null;
            }
            updateConnectionStatus('disconnected');
            addLog('Disconnected from server', 'info');
        }

        function sendRequest() {
            if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                addLog('WebSocket is not connected', 'error');
                return;
            }

            const text = document.getElementById('textInput').value.trim();
            const voice = document.getElementById('voiceSelect').value;
            const temperature = parseFloat(document.getElementById('temperatureSlider').value);
            
            if (!text) {
                addLog('Please enter some text', 'warning');
                return;
            }

            const segmentId = `segment_${Date.now()}`;
            const request = {
                input: text,
                voice: voice,
                temperature: temperature,
                segment_id: segmentId
            };

            addLog(`Sending request: ${JSON.stringify(request)}`, 'info');
            
            try {
                websocket.send(JSON.stringify(request));
            } catch (error) {
                addLog(`Error sending request: ${error.message}`, 'error');
            }
        }

        function handleJSONMessage(message) {
            addLog(`Received: ${JSON.stringify(message)}`, 'info');
            
            switch (message.type) {
                case 'ping':
                    // Respond to server ping with pong
                    try {
                        websocket.send(JSON.stringify({type: 'pong'}));
                        addLog('Sent pong response to server ping', 'debug');
                    } catch (error) {
                        addLog(`Error sending pong: ${error.message}`, 'error');
                    }
                    break;
                case 'start':
                    currentSegmentId = message.segment_id;
                    isReceivingAudio = true;
                    audioBufferQueue = []; // Clear any previous audio
                    isPlaying = false;
                    initializeAudioContext(); // Initialize audio context on first use
                    addLog(`Started receiving audio for segment: ${currentSegmentId}`, 'success');
                    document.getElementById('audioStatus').textContent = 'Receiving and playing audio...';
                    break;
                case 'end':
                    // Don't immediately set isReceivingAudio to false
                    // Let any pending audio chunks be processed first
                    addLog(`Received end message for segment: ${currentSegmentId}`, 'debug');
                    // Use a timeout to ensure all pending audio chunks are processed
                    setTimeout(() => {
                        isReceivingAudio = false;
                        addLog(`Finished receiving audio for segment: ${currentSegmentId}`, 'success');
                        if (audioBufferQueue.length === 0 && !isPlaying) {
                            document.getElementById('audioStatus').textContent = 'Audio playback complete';
                        }
                        currentSegmentId = null;
                    }, 100); // 100ms delay to process pending chunks
                    break;
                case 'error':
                    addLog(`Server error: ${message.message}`, 'error');
                    isReceivingAudio = false;
                    currentSegmentId = null;
                    document.getElementById('audioStatus').textContent = 'Error occurred';
                    break;
            }
        }

        function handleAudioData(data) {
            const chunkSize = data.byteLength || data.length || 0;
            addLog(`handleAudioData called: ${chunkSize} bytes, isReceivingAudio: ${isReceivingAudio}`, 'debug');
            
            if (isReceivingAudio) {
                addLog(`Received audio chunk: ${chunkSize} bytes`, 'info');
                
                if (chunkSize > 0) {
                    // Convert PCM data to Float32Array for Web Audio API
                    const int16Array = new Int16Array(data);
                    const float32Array = new Float32Array(int16Array.length);
                    
                    // Convert int16 to float32 (-1.0 to 1.0)
                    for (let i = 0; i < int16Array.length; i++) {
                        float32Array[i] = int16Array[i] / 32768.0;
                    }
                    
                    // Create audio buffer and queue for playback
                    const audioBuffer = audioContext.createBuffer(1, float32Array.length, 16000);
                    audioBuffer.getChannelData(0).set(float32Array);
                    
                    audioBufferQueue.push(audioBuffer);
                    addLog(`Audio buffer queued. Queue length: ${audioBufferQueue.length}`, 'debug');
                    
                    // Start playback if not already playing
                    if (!isPlaying) {
                        startPlayback();
                    }
                } else {
                    addLog('Warning: Received empty audio chunk', 'warning');
                }
            } else {
                addLog(`Warning: Received audio data but not receiving audio (isReceivingAudio=${isReceivingAudio})`, 'warning');
            }
        }

        function startPlayback() {
            if (audioBufferQueue.length === 0 || isPlaying) return;
            
            isPlaying = true;
            document.getElementById('audioStatus').textContent = 'Playing streaming audio...';
            playNextBuffer();
        }

        function playNextBuffer() {
            if (audioBufferQueue.length === 0) {
                isPlaying = false;
                if (!isReceivingAudio) {
                    document.getElementById('audioStatus').textContent = 'Playback complete';
                }
                return;
            }
            
            const audioBuffer = audioBufferQueue.shift();
            const source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(audioContext.destination);
            
            source.onended = function() {
                // Play next buffer immediately after current one ends
                playNextBuffer();
            };
            
            source.start();
            addLog(`Playing audio buffer: ${audioBuffer.length} samples`, 'info');
        }

        function clearAudio() {
            audioBufferQueue = [];
            isPlaying = false;
            isReceivingAudio = false;
            currentSegmentId = null;
            document.getElementById('audioStatus').textContent = 'Audio cleared';
            addLog('Audio cleared', 'info');
        }

        function clearLogs() {
            document.getElementById('logs').innerHTML = '';
            addLog('Logs cleared', 'info');
        }

        // Initialize on page load
        window.onload = function() {
            addLog('Page loaded. Ready to connect.', 'info');
        };
    </script>
</body>
</html>
